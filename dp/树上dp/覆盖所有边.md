# è¦†ç›–æ‰€æœ‰è¾¹

## ðŸ§  Problem Statement
The city is modeled as a tree with n nodes.

If a soldier is placed on a node u, then all edges connected to u are guarded.

We want to guard all edges using the minimum number of soldiers.

Minimize the number of soldiers such that every edge is guarded, i.e., for every edge (u, v), at least one of u or v must have a soldier.


# idea
this is straight forward tree dp problem, to mark all the edges, we can say if the current node should or should not placed a guard. that is dp[i][0] or dp[i][1] meaning that if we place a guard there or not the minmum solder we need to guard all its subtree edges.

# transition function 
```
Let dp[u][0] and dp[u][1] be:

dp[u][0]: Minimum number of soldiers in subtree rooted at u when u is NOT selected.

dp[u][1]: Minimum number of soldiers in subtree rooted at u when u IS selected.

dp[u][1] = Î£ over children v: min(dp[v][0], dp[v][1])
dp[u][0] = Î£ over children v: dp[v][1]
```

# solution 
```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 10005;

vector<int> tree[MAXN];
int dp[MAXN][2]; // dp[u][0]: u not selected, dp[u][1]: u selected

void dfs(int u, int parent) {
    dp[u][1] = 1;  // placing soldier at u
    dp[u][0] = 0;  // not placing soldier at u

    for (int v : tree[u]) {
        if (v == parent) continue;
        dfs(v, u);

        // u is not selected, so v must be selected
        dp[u][0] += dp[v][1];

        // u is selected, v can be selected or not
        dp[u][1] += min(dp[v][0], dp[v][1]);
    }
}

int main() {
    int n;
    cin >> n;

    // read tree edges
    for (int i = 0; i < n - 1; ++i) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }

    dfs(1, -1); // root the tree at node 1

    cout << min(dp[1][0], dp[1][1]) << endl;

    return 0;
}

```

```rust

use std::io::{self, BufRead};
use std::cmp::min;

fn dfs(
    u: usize,
    parent: usize,
    tree: &Vec<Vec<usize>>,
    dp: &mut Vec<[i32; 2]>,
) {
    dp[u][1] = 1; // placing soldier at node u
    dp[u][0] = 0; // not placing soldier at node u

    for &v in &tree[u] {
        if v == parent {
            continue;
        }
        dfs(v, u, tree, dp);

        dp[u][0] += dp[v][1]; // if u not selected, v must be
        dp[u][1] += min(dp[v][0], dp[v][1]); // if u selected, v can be or not
    }
}

fn main() {
    let stdin = io::stdin();
    let mut lines = stdin.lock().lines();

    let n: usize = lines.next().unwrap().unwrap().trim().parse().unwrap();

    let mut tree = vec![vec![]; n + 1];

    for _ in 0..n - 1 {
        let line = lines.next().unwrap().unwrap();
        let mut parts = line.split_whitespace();
        let u: usize = parts.next().unwrap().parse().unwrap();
        let v: usize = parts.next().unwrap().parse().unwrap();

        tree[u].push(v);
        tree[v].push(u);
    }

    let mut dp = vec![[0, 0]; n + 1];

    dfs(1, 0, &tree, &mut dp);

    println!("{}", min(dp[1][0], dp[1][1]));
}

```