# å¹³è¡¡ç‚¹

## ğŸ§  Problem Statement
ç»™å®šä¸€é¢—æ ‘ï¼Œæ‰¾å‡ºå…¶ä¸­ä¸€ä¸ªç‚¹åˆ é™¤ï¼Œæœ€å¤§çš„è¿é€šå—çš„èŠ‚ç‚¹æ•°é‡å°½é‡çš„å°‘ã€‚

# æ•°æ®
- æ•°æ® ç»™ä¸€ä¸ªnï¼Œm, nä»£è¡¨èŠ‚ç‚¹çš„æ€»æ•°é‡ï¼Œm æ˜¯ è¾¹çš„æ•°é‡, ç„¶åæœ‰m ä¸ª u v,è¡¨ç¤º u å¯ä»¥åˆ°è¾¾vã€‚

## ğŸ’¡ Idea / Approach
- é¦–å…ˆï¼Œå¦‚æœæˆ‘ä»¬çŸ¥é“ å½“å‰æ€»ç»“ç‚¹æœ‰å¤šå°‘ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥é€è¿‡ æ™®é€šçš„dp ç«‹é©¬åªå½“ èŠ‚ç‚¹i çš„ä¸åŒå­æ ‘çš„æ•°é‡ï¼Œå”¯ä¸€éº»çƒ¦çš„æ˜¯ï¼Œä»–çš„çˆ¶äº²èŠ‚ç‚¹çš„æ‰€å½¢æˆçš„é‚£ä¸ªè¿é€šå—çš„æ•°é‡ï¼Œn - å½“å‰å­æ ‘çš„æ€»é‡ åŒ…æ‹¬i
- dp[u] = max(dp[v], n - sum(dp[v] + 1))
- return min(dp)

- transition functions : 
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 100005;
vector<int> tree[MAXN];
int size[MAXN];     // å­æ ‘å¤§å°
int n;
int res = MAXN;     // æœ€å°çš„æœ€å¤§å—
int centroid = -1;  // é‡å¿ƒèŠ‚ç‚¹ç¼–å·

void dfs(int u, int parent) {
    size[u] = 1;
    int max_part = 0;

    for (int v : tree[u]) {
        if (v == parent) continue;
        dfs(v, u);
        size[u] += size[v];
        max_part = max(max_part, size[v]);
    }

    max_part = max(max_part, n - size[u]); // å‰©ä½™éƒ¨åˆ†
    if (max_part < res) {
        res = max_part;
        centroid = u;
    }
}

int main() {
    int m;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }

    dfs(1, -1);
    cout << "Centroid node: " << centroid << ", max block size after removal: " << res << endl;
    return 0;
}

```


```rust

use std::io::{self, BufRead};
use std::collections::VecDeque;

fn main() {
    let stdin = io::stdin();
    let mut lines = stdin.lock().lines();

    // Read n and m
    let first = lines.next().unwrap().unwrap();
    let mut parts = first.split_whitespace();
    let n: usize = parts.next().unwrap().parse().unwrap();
    let m: usize = parts.next().unwrap().parse().unwrap();

    let mut graph = vec![vec![]; n + 1];

    // Read edges
    for _ in 0..m {
        let line = lines.next().unwrap().unwrap();
        let mut parts = line.split_whitespace();
        let u: usize = parts.next().unwrap().parse().unwrap();
        let v: usize = parts.next().unwrap().parse().unwrap();
        graph[u].push(v);
        graph[v].push(u);
    }

    let mut size = vec![0; n + 1];      // subtree sizes
    let mut visited = vec![false; n + 1];
    let mut res = n;
    let mut centroid = 0;

    fn dfs(
        u: usize,
        parent: usize,
        graph: &Vec<Vec<usize>>,
        size: &mut Vec<usize>,
        n: usize,
        res: &mut usize,
        centroid: &mut usize,
    ) {
        size[u] = 1;
        let mut max_part = 0;

        for &v in &graph[u] {
            if v == parent {
                continue;
            }
            dfs(v, u, graph, size, n, res, centroid);
            size[u] += size[v];
            max_part = max_part.max(size[v]);
        }

        max_part = max_part.max(n - size[u]);

        if max_part < *res {
            *res = max_part;
            *centroid = u;
        }
    }

    dfs(1, 0, &graph, &mut size, n, &mut res, &mut centroid);

    println!("Centroid node: {}, Max block size after removal: {}", centroid, res);
}

```