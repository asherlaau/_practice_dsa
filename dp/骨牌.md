# 骨牌（轉化背包）

## 🧠 Problem Statement
給定兩個數組，a 和 b , ai 和 bi 可以翻轉，求出 abs(sum(a) - sum(b)) 為最小值，所需要的最少翻轉次數。 a 和 b的 值得範圍在 1 - 6， n = 100000

## 💡 Idea / Approach
- 首先，a - b 的值不大，由於 ai 和 bi 一對，分別在於 我們 ai - bi 還是 bi - ai 比較接近零而已，就取誰，而且我們能夠知道 要是從左到右 都依次把最優 翻轉次數確保，就可以保證 全局最優解
- 這非常適合dp，由於翻轉次數類似代價，而累積的 差就是價值，而價值越接近0越好，我們可以把方程設置為 dp[i][j]， 當中表示 前i個pair（ai, bi）所組出的 差值j所需的最少翻轉次數。
- 那麼狀態轉移也 迎刃而解，dp[i][j] = dp[i - 1][j - (ai - bi)] 這是沒有翻轉 直接 繼承前序結果，dp[i][j] = dp[i - 1][j - (bi - ai)] + 1 ,這是選取 翻轉後的結果。
- 答案為 min(dp[n][j]) j必須為越小越好，從0， -1 + 1， -2，+2，依次loop找到合法值就返回結果
- dp 的邊界，對於 不能組出的結果 得賦值為 無窮大, dp[0][0] = 0, 其他默認為 無窮大。
- j 有可能出現負數，能夠使用 map 來解決，或者 給 所有數值 +理論最小值，便可利用offset把 負數去掉。

- transition functions : 
```C++
dp[i][j] = min(dp[i - 1][j - (ai - bi)], dp[i - 1][j - (bi - ai)] + 1);
```